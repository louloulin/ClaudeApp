# Claudia 开发指南

## 目录

1. [开发环境搭建](#开发环境搭建)
2. [项目结构详解](#项目结构详解)
3. [核心概念](#核心概念)
4. [开发工作流](#开发工作流)
5. [代码规范](#代码规范)
6. [测试指南](#测试指南)
7. [调试技巧](#调试技巧)
8. [性能优化](#性能优化)
9. [常见问题](#常见问题)

---

## 开发环境搭建

### 系统要求

- **Node.js**: >= 18.0.0
- **Rust**: >= 1.70.0
- **操作系统**: macOS 10.15+, Windows 10+, Linux (Ubuntu 18.04+)

### 安装步骤

#### 1. 安装 Rust

```bash
# 安装 Rust
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source ~/.cargo/env

# 验证安装
rustc --version
cargo --version
```

#### 2. 安装 Node.js

```bash
# 使用 nvm (推荐)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18
nvm use 18

# 或直接下载安装
# https://nodejs.org/
```

#### 3. 安装 Tauri CLI

```bash
# 安装 Tauri CLI
cargo install tauri-cli --version "^2.0.0"

# 验证安装
cargo tauri --version
```

#### 4. 克隆项目

```bash
git clone <repository-url>
cd claudia
```

#### 5. 安装依赖

```bash
# 安装前端依赖
npm install

# 安装 Rust 依赖 (自动)
cd src-tauri
cargo check
cd ..
```

#### 6. 启动开发服务器

```bash
# 启动开发模式
npm run tauri:dev

# 或分别启动
npm run dev        # 前端开发服务器
cargo tauri dev    # Tauri 开发模式
```

### IDE 配置

#### VS Code (推荐)

安装以下扩展：

```json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "tauri-apps.tauri-vscode",
    "bradlc.vscode-tailwindcss",
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-typescript-next"
  ]
}
```

配置文件 `.vscode/settings.json`：

```json
{
  "rust-analyzer.cargo.features": "all",
  "rust-analyzer.checkOnSave.command": "clippy",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "typescript.preferences.importModuleSpecifier": "relative",
  "tailwindCSS.experimental.classRegex": [
    ["cn\\(([^)]*)\\)", "[\"'`]([^\"'`]*).*?[\"'`]"]
  ]
}
```

---

## 项目结构详解

### 前端结构 (`src/`)

```
src/
├── components/              # React 组件
│   ├── ui/                 # 基础 UI 组件 (shadcn/ui)
│   ├── CCAgents.tsx        # CC Agents 主组件
│   ├── CreateAgent.tsx     # 创建代理组件
│   ├── GitHubAgentBrowser.tsx  # GitHub 代理浏览器
│   ├── MCPManager.tsx      # MCP 管理器
│   ├── ProjectsTab.tsx     # 项目标签页
│   ├── UsageDashboard.tsx  # 使用分析仪表板
│   └── ...
├── contexts/               # React Context
│   ├── TabContext.tsx      # 标签页上下文
│   └── ThemeContext.tsx    # 主题上下文
├── hooks/                  # 自定义 Hooks
│   ├── useTabState.ts      # 标签页状态管理
│   ├── useLoadingState.ts  # 加载状态管理
│   └── useDebounce.ts      # 防抖处理
├── lib/                    # 工具库
│   ├── api.ts             # API 接口定义
│   ├── utils.ts           # 工具函数
│   └── constants.ts       # 常量定义
├── stores/                 # Zustand 状态管理
│   ├── sessionStore.ts    # 会话状态
│   └── agentStore.ts      # 代理状态
├── types/                  # TypeScript 类型定义
│   ├── api.ts             # API 类型
│   ├── agent.ts           # 代理类型
│   └── session.ts         # 会话类型
├── styles/                 # 样式文件
│   └── globals.css        # 全局样式
├── App.tsx                 # 主应用组件
├── main.tsx               # 应用入口
└── vite-env.d.ts          # Vite 类型定义
```

### 后端结构 (`src-tauri/src/`)

```
src-tauri/src/
├── commands/               # Tauri 命令模块
│   ├── mod.rs             # 模块索引
│   ├── agents.rs          # 代理相关命令
│   ├── usage.rs           # 使用分析命令
│   ├── mcp.rs             # MCP 管理命令
│   ├── projects.rs        # 项目管理命令
│   └── settings.rs        # 设置管理命令
├── checkpoint.rs           # 检查点功能
├── claude_binary.rs        # Claude 二进制管理
├── main.rs                # 主入口文件
└── lib.rs                 # 库文件
```

### 配置文件

```
├── package.json            # Node.js 依赖和脚本
├── tsconfig.json          # TypeScript 配置
├── tailwind.config.js     # Tailwind CSS 配置
├── vite.config.ts         # Vite 构建配置
├── src-tauri/
│   ├── Cargo.toml         # Rust 依赖配置
│   └── tauri.conf.json    # Tauri 应用配置
└── .eslintrc.json         # ESLint 配置
```

---

## 核心概念

### 1. Tauri 架构

Tauri 采用前后端分离的架构：

- **前端**: React + TypeScript，运行在 WebView 中
- **后端**: Rust，提供系统 API 和业务逻辑
- **通信**: 通过 `invoke` 函数进行前后端通信

```typescript
// 前端调用后端
import { invoke } from '@tauri-apps/api/core';

const result = await invoke('get_projects');
```

```rust
// 后端命令定义
#[tauri::command]
pub async fn get_projects() -> Result<Vec<Project>, String> {
    // 实现逻辑
}
```

### 2. 状态管理模式

#### Zustand Store 模式

```typescript
// 定义状态接口
interface StoreState {
  // 数据状态
  data: DataType[];
  currentItem: DataType | null;
  
  // UI 状态
  isLoading: boolean;
  error: string | null;
  
  // 操作方法
  fetchData: () => Promise<void>;
  setCurrentItem: (item: DataType | null) => void;
  updateItem: (id: string, updates: Partial<DataType>) => void;
}

// 创建 Store
const useStore = create<StoreState>((set, get) => ({
  // 初始状态
  data: [],
  currentItem: null,
  isLoading: false,
  error: null,
  
  // 实现方法
  fetchData: async () => {
    set({ isLoading: true, error: null });
    try {
      const data = await api.getData();
      set({ data, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },
  
  setCurrentItem: (item) => set({ currentItem: item }),
  
  updateItem: (id, updates) => {
    const { data } = get();
    const updatedData = data.map(item => 
      item.id === id ? { ...item, ...updates } : item
    );
    set({ data: updatedData });
  }
}));
```

#### React Context 模式

```typescript
// 定义 Context
interface ContextType {
  state: StateType;
  actions: ActionsType;
}

const Context = createContext<ContextType | undefined>(undefined);

// Provider 组件
export const Provider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [state, setState] = useState<StateType>(initialState);
  
  const actions = useMemo(() => ({
    updateState: (updates: Partial<StateType>) => {
      setState(prev => ({ ...prev, ...updates }));
    }
  }), []);
  
  const value = useMemo(() => ({ state, actions }), [state, actions]);
  
  return (
    <Context.Provider value={value}>
      {children}
    </Context.Provider>
  );
};

// Hook
export const useContext = () => {
  const context = useContext(Context);
  if (!context) {
    throw new Error('useContext must be used within Provider');
  }
  return context;
};
```

### 3. 组件设计模式

#### 容器组件模式

```typescript
// 容器组件：负责数据获取和状态管理
const AgentsContainer: React.FC = () => {
  const { agents, isLoading, error, fetchAgents } = useAgentStore();
  const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);
  
  useEffect(() => {
    fetchAgents();
  }, [fetchAgents]);
  
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <AgentsView
      agents={agents}
      selectedAgent={selectedAgent}
      onSelectAgent={setSelectedAgent}
    />
  );
};

// 展示组件：负责 UI 渲染
interface AgentsViewProps {
  agents: Agent[];
  selectedAgent: Agent | null;
  onSelectAgent: (agent: Agent | null) => void;
}

const AgentsView: React.FC<AgentsViewProps> = ({
  agents,
  selectedAgent,
  onSelectAgent
}) => {
  return (
    <div className="flex h-full">
      <AgentList
        agents={agents}
        selectedAgent={selectedAgent}
        onSelectAgent={onSelectAgent}
      />
      <AgentDetails agent={selectedAgent} />
    </div>
  );
};
```

#### 复合组件模式

```typescript
// 主组件
const AgentCard = ({ agent }: { agent: Agent }) => {
  return (
    <Card>
      <AgentCard.Header agent={agent} />
      <AgentCard.Content agent={agent} />
      <AgentCard.Actions agent={agent} />
    </Card>
  );
};

// 子组件
AgentCard.Header = ({ agent }: { agent: Agent }) => (
  <CardHeader>
    <div className="flex items-center gap-2">
      <span className="text-2xl">{agent.icon}</span>
      <h3 className="font-semibold">{agent.name}</h3>
    </div>
  </CardHeader>
);

AgentCard.Content = ({ agent }: { agent: Agent }) => (
  <CardContent>
    <p className="text-sm text-muted-foreground">
      {agent.system_prompt.slice(0, 100)}...
    </p>
  </CardContent>
);

AgentCard.Actions = ({ agent }: { agent: Agent }) => (
  <CardFooter>
    <Button size="sm">执行</Button>
    <Button size="sm" variant="outline">编辑</Button>
  </CardFooter>
);
```

---

## 开发工作流

### 1. 功能开发流程

#### 步骤 1: 需求分析
- 明确功能需求和用户故事
- 设计 API 接口和数据结构
- 确定 UI/UX 设计

#### 步骤 2: 后端开发

```rust
// 1. 定义数据结构
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct NewFeature {
    pub id: Option<i64>,
    pub name: String,
    pub data: String,
    pub created_at: String,
}

// 2. 实现 Tauri 命令
#[tauri::command]
pub async fn create_feature(
    name: String,
    data: String,
) -> Result<NewFeature, String> {
    // 实现业务逻辑
    let feature = NewFeature {
        id: None,
        name,
        data,
        created_at: chrono::Utc::now().to_rfc3339(),
    };
    
    // 保存到数据库
    save_feature(&feature).await
        .map_err(|e| e.to_string())
}

// 3. 注册命令
fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            create_feature,
            // 其他命令...
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

#### 步骤 3: 前端开发

```typescript
// 1. 定义 API 接口
export const api = {
  createFeature: (name: string, data: string): Promise<NewFeature> =>
    invoke('create_feature', { name, data }),
    
  getFeatures: (): Promise<NewFeature[]> =>
    invoke('get_features'),
};

// 2. 创建状态管理
interface FeatureState {
  features: NewFeature[];
  isLoading: boolean;
  error: string | null;
  createFeature: (name: string, data: string) => Promise<void>;
  fetchFeatures: () => Promise<void>;
}

const useFeatureStore = create<FeatureState>((set, get) => ({
  features: [],
  isLoading: false,
  error: null,
  
  createFeature: async (name, data) => {
    set({ isLoading: true, error: null });
    try {
      const feature = await api.createFeature(name, data);
      const { features } = get();
      set({ features: [...features, feature], isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },
  
  fetchFeatures: async () => {
    set({ isLoading: true, error: null });
    try {
      const features = await api.getFeatures();
      set({ features, isLoading: false });
    } catch (error) {
      set({ error: error.message, isLoading: false });
    }
  },
}));

// 3. 创建 UI 组件
const FeatureManager: React.FC = () => {
  const { features, isLoading, error, createFeature, fetchFeatures } = useFeatureStore();
  const [isCreateModalOpen, setIsCreateModalOpen] = useState(false);
  
  useEffect(() => {
    fetchFeatures();
  }, [fetchFeatures]);
  
  const handleCreateFeature = async (name: string, data: string) => {
    await createFeature(name, data);
    setIsCreateModalOpen(false);
  };
  
  return (
    <div className="p-4">
      <div className="flex items-center justify-between mb-4">
        <h2 className="text-lg font-semibold">功能管理</h2>
        <Button onClick={() => setIsCreateModalOpen(true)}>
          创建功能
        </Button>
      </div>
      
      {isLoading && <LoadingSpinner />}
      {error && <ErrorMessage error={error} />}
      
      <div className="grid gap-4">
        {features.map(feature => (
          <FeatureCard key={feature.id} feature={feature} />
        ))}
      </div>
      
      <CreateFeatureModal
        isOpen={isCreateModalOpen}
        onClose={() => setIsCreateModalOpen(false)}
        onSave={handleCreateFeature}
      />
    </div>
  );
};
```

#### 步骤 4: 测试

```typescript
// 单元测试
import { renderHook, act } from '@testing-library/react';
import { useFeatureStore } from '../stores/featureStore';

describe('useFeatureStore', () => {
  it('should create feature successfully', async () => {
    const { result } = renderHook(() => useFeatureStore());
    
    await act(async () => {
      await result.current.createFeature('Test Feature', 'Test Data');
    });
    
    expect(result.current.features).toHaveLength(1);
    expect(result.current.features[0].name).toBe('Test Feature');
  });
});

// 集成测试
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { FeatureManager } from '../components/FeatureManager';

describe('FeatureManager', () => {
  it('should display features and allow creation', async () => {
    render(<FeatureManager />);
    
    // 点击创建按钮
    fireEvent.click(screen.getByText('创建功能'));
    
    // 填写表单
    fireEvent.change(screen.getByLabelText('名称'), {
      target: { value: 'New Feature' }
    });
    
    // 提交表单
    fireEvent.click(screen.getByText('保存'));
    
    // 验证结果
    await waitFor(() => {
      expect(screen.getByText('New Feature')).toBeInTheDocument();
    });
  });
});
```

### 2. Git 工作流

#### 分支策略

```bash
# 主分支
main          # 生产环境代码
develop       # 开发环境代码

# 功能分支
feature/agent-management
feature/usage-dashboard
feature/mcp-integration

# 修复分支
hotfix/critical-bug-fix
bugfix/minor-issue

# 发布分支
release/v1.0.0
```

#### 提交规范

```bash
# 提交消息格式
<type>(<scope>): <description>

[optional body]

[optional footer]

# 类型
feat:     新功能
fix:      修复 bug
docs:     文档更新
style:    代码格式化
refactor: 重构代码
test:     添加测试
chore:    构建过程或辅助工具的变动

# 示例
feat(agents): add agent execution functionality
fix(ui): resolve tab switching issue
docs(api): update API documentation
refactor(store): simplify state management logic
```

#### 代码审查清单

- [ ] 代码符合项目规范
- [ ] 功能实现正确且完整
- [ ] 包含必要的测试
- [ ] 文档已更新
- [ ] 性能影响可接受
- [ ] 安全性考虑充分
- [ ] 错误处理完善
- [ ] 用户体验良好

---

## 代码规范

### TypeScript 规范

#### 命名约定

```typescript
// 变量和函数：camelCase
const userName = 'john';
const getUserData = () => {};

// 常量：SCREAMING_SNAKE_CASE
const API_BASE_URL = 'https://api.example.com';
const MAX_RETRY_COUNT = 3;

// 类型和接口：PascalCase
interface UserData {
  id: string;
  name: string;
}

type ApiResponse<T> = {
  data: T;
  status: number;
};

// 组件：PascalCase
const UserProfile: React.FC<UserProfileProps> = ({ user }) => {
  return <div>{user.name}</div>;
};

// 枚举：PascalCase
enum UserRole {
  Admin = 'admin',
  User = 'user',
  Guest = 'guest'
}
```

#### 类型定义

```typescript
// 优先使用 interface
interface User {
  id: string;
  name: string;
  email: string;
  role: UserRole;
}

// 复杂类型使用 type
type EventHandler<T> = (event: T) => void;
type ApiEndpoint = `/api/${string}`;

// 泛型约束
interface Repository<T extends { id: string }> {
  findById(id: string): Promise<T | null>;
  save(entity: T): Promise<T>;
  delete(id: string): Promise<void>;
}

// 工具类型
type PartialUser = Partial<User>;
type UserWithoutId = Omit<User, 'id'>;
type UserEmail = Pick<User, 'email'>;
```

#### 错误处理

```typescript
// 使用 Result 模式
type Result<T, E = Error> = 
  | { success: true; data: T }
  | { success: false; error: E };

const fetchUser = async (id: string): Promise<Result<User>> => {
  try {
    const user = await api.getUser(id);
    return { success: true, data: user };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error : new Error('Unknown error')
    };
  }
};

// 使用示例
const result = await fetchUser('123');
if (result.success) {
  console.log(result.data.name);
} else {
  console.error(result.error.message);
}
```

### React 规范

#### 组件结构

```typescript
// 组件文件结构
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { SomeExternalLibrary } from 'external-library';

import { Button } from '@/components/ui/button';
import { useCustomHook } from '@/hooks/useCustomHook';
import { api } from '@/lib/api';
import type { ComponentProps } from '@/types';

// 类型定义
interface Props {
  title: string;
  onSave?: (data: string) => void;
  children?: React.ReactNode;
}

// 组件实现
export const MyComponent: React.FC<Props> = ({ 
  title, 
  onSave, 
  children 
}) => {
  // Hooks
  const [data, setData] = useState<string>('');
  const { isLoading, error } = useCustomHook();
  
  // 计算属性
  const isValid = useMemo(() => {
    return data.length > 0;
  }, [data]);
  
  // 事件处理
  const handleSave = useCallback(() => {
    if (isValid && onSave) {
      onSave(data);
    }
  }, [data, isValid, onSave]);
  
  // 副作用
  useEffect(() => {
    // 组件挂载时的逻辑
  }, []);
  
  // 渲染
  return (
    <div className="p-4">
      <h2 className="text-lg font-semibold mb-4">{title}</h2>
      
      {error && (
        <div className="text-red-500 mb-4">{error}</div>
      )}
      
      <div className="space-y-4">
        {children}
        
        <Button 
          onClick={handleSave}
          disabled={!isValid || isLoading}
        >
          {isLoading ? '保存中...' : '保存'}
        </Button>
      </div>
    </div>
  );
};

// 默认导出
export default MyComponent;
```

#### Hooks 规范

```typescript
// 自定义 Hook
export const useApi = <T>(endpoint: string) => {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      const result = await api.get<T>(endpoint);
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    } finally {
      setIsLoading(false);
    }
  }, [endpoint]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return {
    data,
    isLoading,
    error,
    refetch: fetchData
  };
};
```

### Rust 规范

#### 命名约定

```rust
// 变量和函数：snake_case
let user_name = "john";
fn get_user_data() -> UserData {}

// 常量：SCREAMING_SNAKE_CASE
const API_BASE_URL: &str = "https://api.example.com";
const MAX_RETRY_COUNT: u32 = 3;

// 结构体和枚举：PascalCase
struct UserData {
    id: String,
    name: String,
}

enum UserRole {
    Admin,
    User,
    Guest,
}

// 模块：snake_case
mod user_management;
mod api_client;
```

#### 错误处理

```rust
// 使用 Result 类型
use anyhow::{Result, Context};

#[tauri::command]
pub async fn create_user(name: String, email: String) -> Result<User, String> {
    let user = User::new(name, email)
        .context("Failed to create user")
        .map_err(|e| e.to_string())?;
    
    save_user(&user).await
        .context("Failed to save user")
        .map_err(|e| e.to_string())?;
    
    Ok(user)
}

// 自定义错误类型
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("Validation error: {0}")]
    Validation(String),
    
    #[error("Not found: {0}")]
    NotFound(String),
}
```

#### 异步编程

```rust
// 使用 async/await
use tokio::time::{sleep, Duration};

#[tauri::command]
pub async fn process_data(data: Vec<String>) -> Result<Vec<ProcessedData>, String> {
    let mut results = Vec::new();
    
    for item in data {
        let processed = process_item(item).await
            .map_err(|e| e.to_string())?;
        results.push(processed);
        
        // 避免阻塞
        sleep(Duration::from_millis(10)).await;
    }
    
    Ok(results)
}

async fn process_item(item: String) -> Result<ProcessedData> {
    // 异步处理逻辑
    Ok(ProcessedData { value: item })
}
```

---

## 测试指南

### 前端测试

#### 单元测试

```typescript
// 测试工具函数
import { describe, it, expect } from 'vitest';
import { formatDate, validateEmail } from '@/lib/utils';

describe('utils', () => {
  describe('formatDate', () => {
    it('should format date correctly', () => {
      const date = new Date('2024-01-01T12:00:00Z');
      const formatted = formatDate(date);
      expect(formatted).toBe('2024-01-01');
    });
  });
  
  describe('validateEmail', () => {
    it('should validate correct email', () => {
      expect(validateEmail('test@example.com')).toBe(true);
    });
    
    it('should reject invalid email', () => {
      expect(validateEmail('invalid-email')).toBe(false);
    });
  });
});
```

#### 组件测试

```typescript
// 测试 React 组件
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { UserProfile } from '@/components/UserProfile';

describe('UserProfile', () => {
  const mockUser = {
    id: '1',
    name: 'John Doe',
    email: 'john@example.com'
  };
  
  it('should display user information', () => {
    render(<UserProfile user={mockUser} />);
    
    expect(screen.getByText('John Doe')).toBeInTheDocument();
    expect(screen.getByText('john@example.com')).toBeInTheDocument();
  });
  
  it('should call onEdit when edit button is clicked', () => {
    const onEdit = vi.fn();
    render(<UserProfile user={mockUser} onEdit={onEdit} />);
    
    fireEvent.click(screen.getByText('编辑'));
    
    expect(onEdit).toHaveBeenCalledWith(mockUser);
  });
});
```

#### Hook 测试

```typescript
// 测试自定义 Hook
import { renderHook, act } from '@testing-library/react';
import { vi } from 'vitest';
import { useCounter } from '@/hooks/useCounter';

describe('useCounter', () => {
  it('should initialize with default value', () => {
    const { result } = renderHook(() => useCounter());
    
    expect(result.current.count).toBe(0);
  });
  
  it('should increment count', () => {
    const { result } = renderHook(() => useCounter());
    
    act(() => {
      result.current.increment();
    });
    
    expect(result.current.count).toBe(1);
  });
});
```

#### Store 测试

```typescript
// 测试 Zustand Store
import { act, renderHook } from '@testing-library/react';
import { useUserStore } from '@/stores/userStore';

describe('useUserStore', () => {
  beforeEach(() => {
    // 重置 store 状态
    useUserStore.getState().reset();
  });
  
  it('should add user', () => {
    const { result } = renderHook(() => useUserStore());
    const user = { id: '1', name: 'John' };
    
    act(() => {
      result.current.addUser(user);
    });
    
    expect(result.current.users).toContain(user);
  });
});
```

### 后端测试

#### 单元测试

```rust
// Rust 单元测试
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_create_user() {
        let user = User::new("John".to_string(), "john@example.com".to_string());
        assert!(user.is_ok());
        
        let user = user.unwrap();
        assert_eq!(user.name, "John");
        assert_eq!(user.email, "john@example.com");
    }
    
    #[test]
    fn test_validate_email() {
        assert!(validate_email("test@example.com"));
        assert!(!validate_email("invalid-email"));
    }
}
```

#### 集成测试

```rust
// 集成测试
#[cfg(test)]
mod integration_tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn test_user_crud_operations() {
        // 创建用户
        let user = create_user("John".to_string(), "john@example.com".to_string()).await;
        assert!(user.is_ok());
        
        let user = user.unwrap();
        let user_id = user.id.clone();
        
        // 获取用户
        let retrieved_user = get_user(user_id.clone()).await;
        assert!(retrieved_user.is_ok());
        assert_eq!(retrieved_user.unwrap().name, "John");
        
        // 删除用户
        let result = delete_user(user_id).await;
        assert!(result.is_ok());
    }
}
```

### E2E 测试

```typescript
// Playwright E2E 测试
import { test, expect } from '@playwright/test';

test.describe('Agent Management', () => {
  test('should create and execute agent', async ({ page }) => {
    // 导航到应用
    await page.goto('/');
    
    // 打开 CC Agents 标签
    await page.click('text=CC Agents');
    
    // 创建新代理
    await page.click('text=创建代理');
    await page.fill('[placeholder="代理名称"]', 'Test Agent');
    await page.fill('[placeholder="系统提示"]', 'You are a test agent');
    await page.click('text=保存');
    
    // 验证代理已创建
    await expect(page.locator('text=Test Agent')).toBeVisible();
    
    // 执行代理
    await page.click('text=Test Agent');
    await page.click('text=执行');
    await page.fill('[placeholder="任务描述"]', 'Test task');
    await page.click('text=开始执行');
    
    // 验证执行状态
    await expect(page.locator('text=执行中')).toBeVisible();
  });
});
```

---

## 调试技巧

### 前端调试

#### 浏览器开发者工具

```typescript
// 使用 console 调试
console.log('Debug info:', { data, state });
console.table(arrayData);
console.group('API Call');
console.log('Request:', request);
console.log('Response:', response);
console.groupEnd();

// 使用 debugger 断点
const processData = (data: any[]) => {
  debugger; // 浏览器会在此处暂停
  return data.map(item => transform(item));
};

// React DevTools
// 安装 React DevTools 浏览器扩展
// 可以查看组件树、props、state 等
```

#### Zustand DevTools

```typescript
// 启用 Zustand DevTools
import { devtools } from 'zustand/middleware';

const useStore = create<State>()()
  devtools(
    (set, get) => ({
      // store 实现
    }),
    {
      name: 'user-store', // DevTools 中显示的名称
    }
  )
);
```

#### 网络请求调试

```typescript
// API 调试中间件
const apiWithLogging = {
  async invoke<T>(command: string, args?: any): Promise<T> {
    console.group(`API Call: ${command}`);
    console.log('Arguments:', args);
    
    const startTime = performance.now();
    
    try {
      const result = await invoke<T>(command, args);
      const endTime = performance.now();
      
      console.log('Result:', result);
      console.log(`Duration: ${endTime - startTime}ms`);
      console.groupEnd();
      
      return result;
    } catch (error) {
      console.error('Error:', error);
      console.groupEnd();
      throw error;
    }
  }
};
```

### 后端调试

#### Rust 调试

```rust
// 使用 log 宏
use log::{debug, info, warn, error};

#[tauri::command]
pub async fn process_data(data: String) -> Result<String, String> {
    info!("Processing data: {}", data);
    
    match validate_data(&data) {
        Ok(_) => {
            debug!("Data validation passed");
            // 处理逻辑
        }
        Err(e) => {
            warn!("Data validation failed: {}", e);
            return Err(e.to_string());
        }
    }
    
    Ok("processed".to_string())
}

// 使用 dbg! 宏进行快速调试
let result = dbg!(expensive_calculation());

// 条件编译调试代码
#[cfg(debug_assertions)]
println!("Debug mode: {:?}", debug_info);
```

#### 性能分析

```rust
// 使用 std::time 测量性能
use std::time::Instant;

let start = Instant::now();
let result = expensive_operation();
let duration = start.elapsed();
println!("Operation took: {:?}", duration);

// 使用 tracing 进行详细追踪
use tracing::{instrument, info_span};

#[instrument]
async fn process_user_data(user_id: String) -> Result<UserData> {
    let span = info_span!("database_query", user_id = %user_id);
    let _enter = span.enter();
    
    // 数据库查询
    let user = database.get_user(&user_id).await?;
    
    Ok(user)
}
```

### 常见问题排查

#### 前端问题

```typescript
// 1. 状态更新不生效
// 问题：直接修改状态对象
const badUpdate = () => {
  state.items.push(newItem); // ❌ 错误
  setState(state);
};

// 解决：创建新对象
const goodUpdate = () => {
  setState({
    ...state,
    items: [...state.items, newItem] // ✅ 正确
  });
};

// 2. 无限重新渲染
// 问题：useEffect 依赖项错误
useEffect(() => {
  fetchData();
}, [fetchData]); // ❌ fetchData 每次都是新函数

// 解决：使用 useCallback
const fetchData = useCallback(async () => {
  // 获取数据逻辑
}, [dependency]);

useEffect(() => {
  fetchData();
}, [fetchData]); // ✅ 正确

// 3. 内存泄漏
// 问题：未清理副作用
useEffect(() => {
  const timer = setInterval(() => {
    // 定时器逻辑
  }, 1000);
  
  // ❌ 未清理定时器
}, []);

// 解决：返回清理函数
useEffect(() => {
  const timer = setInterval(() => {
    // 定时器逻辑
  }, 1000);
  
  return () => clearInterval(timer); // ✅ 清理定时器
}, []);
```

#### 后端问题

```rust
// 1. 异步函数阻塞
// 问题：在异步函数中使用阻塞操作
#[tauri::command]
pub async fn bad_async_function() -> Result<String, String> {
    std::thread::sleep(Duration::from_secs(5)); // ❌ 阻塞整个异步运行时
    Ok("done".to_string())
}

// 解决：使用异步等待
#[tauri::command]
pub async fn good_async_function() -> Result<String, String> {
    tokio::time::sleep(Duration::from_secs(5)).await; // ✅ 异步等待
    Ok("done".to_string())
}

// 2. 错误处理不当
// 问题：忽略错误或使用 unwrap
let result = risky_operation().unwrap(); // ❌ 可能导致 panic

// 解决：适当的错误处理
let result = risky_operation()
    .map_err(|e| format!("Operation failed: {}", e))?; // ✅ 传播错误

// 3. 资源泄漏
// 问题：未正确管理资源
let file = File::open("data.txt")?;
// ❌ 文件可能未正确关闭

// 解决：使用 RAII 或显式管理
{
    let file = File::open("data.txt")?;
    // 使用文件
} // ✅ 文件在作用域结束时自动关闭
```

---

## 性能优化

### 前端性能优化

#### React 优化

```typescript
// 1. 使用 React.memo 避免不必要的重新渲染
const ExpensiveComponent = React.memo<Props>(({ data, onUpdate }) => {
  return (
    <div>
      {data.map(item => (
        <ItemComponent key={item.id} item={item} onUpdate={onUpdate} />
      ))}
    </div>
  );
}, (prevProps, nextProps) => {
  // 自定义比较函数
  return prevProps.data.length === nextProps.data.length &&
         prevProps.data.every((item, index) => 
           item.id === nextProps.data[index].id
         );
});

// 2. 使用 useMemo 缓存计算结果
const ExpensiveCalculation: React.FC<{ items: Item[] }> = ({ items }) => {
  const expensiveValue = useMemo(() => {
    return items.reduce((sum, item) => sum + item.value, 0);
  }, [items]);
  
  const filteredItems = useMemo(() => {
    return items.filter(item => item.active);
  }, [items]);
  
  return (
    <div>
      <p>Total: {expensiveValue}</p>
      <ItemList items={filteredItems} />
    </div>
  );
};

// 3. 使用 useCallback 缓存函数
const ParentComponent: React.FC = () => {
  const [items, setItems] = useState<Item[]>([]);
  
  const handleItemUpdate = useCallback((id: string, updates: Partial<Item>) => {
    setItems(prev => prev.map(item => 
      item.id === id ? { ...item, ...updates } : item
    ));
  }, []);
  
  const handleItemDelete = useCallback((id: string) => {
    setItems(prev => prev.filter(item => item.id !== id));
  }, []);
  
  return (
    <ItemList 
      items={items}
      onUpdate={handleItemUpdate}
      onDelete={handleItemDelete}
    />
  );
};

// 4. 虚拟化长列表
import { FixedSizeList as List } from 'react-window';

const VirtualizedList: React.FC<{ items: Item[] }> = ({ items }) => {
  const Row = ({ index, style }: { index: number; style: React.CSSProperties }) => (
    <div style={style}>
      <ItemComponent item={items[index]} />
    </div>
  );
  
  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={50}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

#### 状态管理优化

```typescript
// 1. 分割 Zustand Store
// 避免单一大型 store，按功能分割
const useUserStore = create<UserState>((set) => ({
  users: [],
  currentUser: null,
  // 用户相关操作
}));

const useUIStore = create<UIState>((set) => ({
  theme: 'dark',
  sidebarOpen: false,
  // UI 相关操作
}));

// 2. 使用选择器避免不必要的重新渲染
const Component: React.FC = () => {
  // ❌ 整个 store 变化都会重新渲染
  const store = useUserStore();
  
  // ✅ 只有 users 变化才会重新渲染
  const users = useUserStore(state => state.users);
  const addUser = useUserStore(state => state.addUser);
  
  return (
    <div>
      {users.map(user => <UserItem key={user.id} user={user} />)}
    </div>
  );
};

// 3. 批量更新
const useBatchedStore = create<State>((set) => ({
  items: [],
  updateMultipleItems: (updates: Array<{ id: string; data: any }>) => {
    set(state => ({
      items: state.items.map(item => {
        const update = updates.find(u => u.id === item.id);
        return update ? { ...item, ...update.data } : item;
      })
    }));
  }
}));
```

#### 网络请求优化

```typescript
// 1. 请求去重
const requestCache = new Map<string, Promise<any>>();

const cachedInvoke = async <T>(command: string, args?: any): Promise<T> => {
  const key = `${command}:${JSON.stringify(args)}`;
  
  if (requestCache.has(key)) {
    return requestCache.get(key)!;
  }
  
  const promise = invoke<T>(command, args);
  requestCache.set(key, promise);
  
  try {
    const result = await promise;
    return result;
  } finally {
    // 请求完成后清除缓存
    setTimeout(() => requestCache.delete(key), 5000);
  }
};

// 2. 请求批处理
class BatchProcessor {
  private batch: Array<{ command: string; args: any; resolve: Function; reject: Function }> = [];
  private timer: NodeJS.Timeout | null = null;
  
  async add<T>(command: string, args?: any): Promise<T> {
    return new Promise((resolve, reject) => {
      this.batch.push({ command, args, resolve, reject });
      
      if (this.timer) {
        clearTimeout(this.timer);
      }
      
      this.timer = setTimeout(() => this.processBatch(), 10);
    });
  }
  
  private async processBatch() {
    const currentBatch = [...this.batch];
    this.batch = [];
    
    try {
      const results = await invoke('batch_process', { requests: currentBatch });
      currentBatch.forEach((item, index) => {
        item.resolve(results[index]);
      });
    } catch (error) {
      currentBatch.forEach(item => {
        item.reject(error);
      });
    }
  }
}

const batchProcessor = new BatchProcessor();

// 3. 数据预加载
const usePreloadData = () => {
  useEffect(() => {
    // 预加载常用数据
    const preloadPromises = [
      invoke('get_user_preferences'),
      invoke('get_recent_projects'),
      invoke('get_agent_templates')
    ];
    
    Promise.all(preloadPromises).catch(console.error);
  }, []);
};
```

### 后端性能优化

#### Rust 优化

```rust
// 1. 使用连接池
use sqlx::{Pool, Sqlite};
use std::sync::Arc;

pub struct AppState {
    db_pool: Arc<Pool<Sqlite>>,
}

#[tauri::command]
pub async fn get_users(
    state: tauri::State<'_, AppState>
) -> Result<Vec<User>, String> {
    let users = sqlx::query_as!(User, "SELECT * FROM users")
        .fetch_all(&*state.db_pool)
        .await
        .map_err(|e| e.to_string())?;
    
    Ok(users)
}

// 2. 批量操作
#[tauri::command]
pub async fn batch_update_users(
    updates: Vec<UserUpdate>,
    state: tauri::State<'_, AppState>
) -> Result<(), String> {
    let mut tx = state.db_pool.begin().await.map_err(|e| e.to_string())?;
    
    for update in updates {
        sqlx::query!("UPDATE users SET name = ? WHERE id = ?", update.name, update.id)
            .execute(&mut *tx)
            .await
            .map_err(|e| e.to_string())?;
    }
    
    tx.commit().await.map_err(|e| e.to_string())?;
    Ok(())
}

// 3. 异步并发处理
use tokio::task::JoinSet;

#[tauri::command]
pub async fn process_multiple_files(
    file_paths: Vec<String>
) -> Result<Vec<ProcessResult>, String> {
    let mut set = JoinSet::new();
    
    for path in file_paths {
        set.spawn(async move {
            process_file(path).await
        });
    }
    
    let mut results = Vec::new();
    while let Some(result) = set.join_next().await {
        match result {
            Ok(Ok(processed)) => results.push(processed),
            Ok(Err(e)) => return Err(e),
            Err(e) => return Err(e.to_string()),
        }
    }
    
    Ok(results)
}

// 4. 内存优化
use std::collections::HashMap;
use std::sync::RwLock;

// 使用 RwLock 而不是 Mutex 进行读多写少的场景
pub struct Cache {
    data: RwLock<HashMap<String, CachedData>>,
}

impl Cache {
    pub fn get(&self, key: &str) -> Option<CachedData> {
        let data = self.data.read().unwrap();
        data.get(key).cloned()
    }
    
    pub fn set(&self, key: String, value: CachedData) {
        let mut data = self.data.write().unwrap();
        data.insert(key, value);
    }
}

// 5. 流式处理大数据
use tokio::io::{AsyncBufReadExt, BufReader};
use tokio::fs::File;

#[tauri::command]
pub async fn process_large_file(
    file_path: String
) -> Result<ProcessSummary, String> {
    let file = File::open(file_path).await.map_err(|e| e.to_string())?;
    let reader = BufReader::new(file);
    let mut lines = reader.lines();
    
    let mut summary = ProcessSummary::default();
    
    while let Some(line) = lines.next_line().await.map_err(|e| e.to_string())? {
        // 逐行处理，避免将整个文件加载到内存
        process_line(&line, &mut summary);
    }
    
    Ok(summary)
}
```

---

## 常见问题

### 开发环境问题

#### Q: Tauri 开发服务器启动失败

**A: 检查以下几点：**

1. 确保 Rust 和 Node.js 版本符合要求
2. 检查端口是否被占用
3. 清理缓存并重新安装依赖

```bash
# 清理缓存
npm run clean
rm -rf node_modules
rm -rf src-tauri/target

# 重新安装
npm install
cargo clean

# 重新启动
npm run tauri:dev
```

#### Q: TypeScript 类型错误

**A: 常见解决方案：**

```typescript
// 1. 更新类型定义
npm install --save-dev @types/node @types/react @types/react-dom

// 2. 检查 tsconfig.json 配置
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

// 3. 添加类型声明文件
// src/types/global.d.ts
declare global {
  interface Window {
    __TAURI__: any;
  }
}
```

#### Q: Rust 编译错误

**A: 常见解决方案：**

```bash
# 1. 更新 Rust 工具链
rustup update

# 2. 清理构建缓存
cargo clean

# 3. 检查依赖版本冲突
cargo tree --duplicates

# 4. 修复 Cargo.lock
rm Cargo.lock
cargo build
```

### 运行时问题

#### Q: 前后端通信失败

**A: 检查以下几点：**

```typescript
// 1. 确保命令已注册
// src-tauri/src/main.rs
fn main() {
    tauri::Builder::default()
        .invoke_handler(tauri::generate_handler![
            your_command_name  // 确保命令在这里
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

// 2. 检查命令签名
#[tauri::command]
pub async fn your_command_name(
    param: String  // 参数类型必须匹配
) -> Result<ReturnType, String> {
    // 实现
}

// 3. 前端调用检查
try {
    const result = await invoke('your_command_name', { param: 'value' });
    console.log(result);
} catch (error) {
    console.error('Command failed:', error);
}
```

#### Q: 状态更新不生效

**A: 常见原因和解决方案：**

```typescript
// 1. 直接修改状态对象
// ❌ 错误做法
const updateUser = (userId: string, name: string) => {
    const user = users.find(u => u.id === userId);
    user.name = name; // 直接修改
    setUsers(users); // 引用相同，不会触发更新
};

// ✅ 正确做法
const updateUser = (userId: string, name: string) => {
    setUsers(prev => prev.map(user => 
        user.id === userId ? { ...user, name } : user
    ));
};

// 2. 异步状态更新
// ❌ 错误做法
const handleMultipleUpdates = () => {
    setCount(count + 1);
    setCount(count + 1); // 使用旧的 count 值
};

// ✅ 正确做法
const handleMultipleUpdates = () => {
    setCount(prev => prev + 1);
    setCount(prev => prev + 1); // 使用最新的值
};
```

#### Q: 内存泄漏

**A: 常见原因和解决方案：**

```typescript
// 1. 未清理事件监听器
useEffect(() => {
    const handleResize = () => {
        // 处理窗口大小变化
    };
    
    window.addEventListener('resize', handleResize);
    
    // ✅ 清理事件监听器
    return () => {
        window.removeEventListener('resize', handleResize);
    };
}, []);

// 2. 未清理定时器
useEffect(() => {
    const timer = setInterval(() => {
        // 定时任务
    }, 1000);
    
    // ✅ 清理定时器
    return () => clearInterval(timer);
}, []);

// 3. 未取消网络请求
useEffect(() => {
    const abortController = new AbortController();
    
    const fetchData = async () => {
        try {
            const result = await invoke('get_data', {
                signal: abortController.signal
            });
            setData(result);
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error(error);
            }
        }
    };
    
    fetchData();
    
    // ✅ 取消请求
    return () => abortController.abort();
}, []);
```

### 性能问题

#### Q: 应用启动缓慢

**A: 优化策略：**

```typescript
// 1. 懒加载组件
const LazyComponent = React.lazy(() => import('./HeavyComponent'));

const App = () => {
    return (
        <Suspense fallback={<LoadingSpinner />}>
            <LazyComponent />
        </Suspense>
    );
};

// 2. 代码分割
const routes = [
    {
        path: '/agents',
        component: React.lazy(() => import('./pages/AgentsPage'))
    },
    {
        path: '/usage',
        component: React.lazy(() => import('./pages/UsagePage'))
    }
];

// 3. 预加载关键数据
const useAppInitialization = () => {
    useEffect(() => {
        // 并行加载关键数据
        Promise.all([
            invoke('get_user_settings'),
            invoke('get_recent_projects'),
            invoke('check_claude_status')
        ]).then(([settings, projects, status]) => {
            // 初始化应用状态
        }).catch(console.error);
    }, []);
};
```

#### Q: 大量数据渲染卡顿

**A: 优化方案：**

```typescript
// 1. 虚拟化列表
import { FixedSizeList } from 'react-window';

const VirtualList = ({ items }: { items: Item[] }) => {
    const Row = ({ index, style }: any) => (
        <div style={style}>
            <ItemComponent item={items[index]} />
        </div>
    );
    
    return (
        <FixedSizeList
            height={400}
            itemCount={items.length}
            itemSize={50}
        >
            {Row}
        </FixedSizeList>
    );
};

// 2. 分页加载
const usePaginatedData = <T>(fetchFn: (page: number) => Promise<T[]>) => {
    const [data, setData] = useState<T[]>([]);
    const [page, setPage] = useState(1);
    const [hasMore, setHasMore] = useState(true);
    const [isLoading, setIsLoading] = useState(false);
    
    const loadMore = useCallback(async () => {
        if (isLoading || !hasMore) return;
        
        setIsLoading(true);
        try {
            const newData = await fetchFn(page);
            if (newData.length === 0) {
                setHasMore(false);
            } else {
                setData(prev => [...prev, ...newData]);
                setPage(prev => prev + 1);
            }
        } catch (error) {
            console.error('Failed to load more data:', error);
        } finally {
            setIsLoading(false);
        }
    }, [fetchFn, page, isLoading, hasMore]);
    
    return { data, loadMore, hasMore, isLoading };
};

// 3. 防抖搜索
const useSearch = <T>(searchFn: (query: string) => Promise<T[]>) => {
    const [query, setQuery] = useState('');
    const [results, setResults] = useState<T[]>([]);
    const [isSearching, setIsSearching] = useState(false);
    
    const debouncedQuery = useDebounce(query, 300);
    
    useEffect(() => {
        if (!debouncedQuery) {
            setResults([]);
            return;
        }
        
        setIsSearching(true);
        searchFn(debouncedQuery)
            .then(setResults)
            .catch(console.error)
            .finally(() => setIsSearching(false));
    }, [debouncedQuery, searchFn]);
    
    return { query, setQuery, results, isSearching };
};
```

### 部署问题

#### Q: 构建失败

**A: 检查步骤：**

```bash
# 1. 检查构建环境
node --version  # >= 18.0.0
rustc --version # >= 1.70.0

# 2. 清理并重新构建
npm run clean
npm install
npm run build
npm run tauri:build

# 3. 检查构建日志
npm run tauri:build 2>&1 | tee build.log

# 4. 检查依赖冲突
npm ls
cargo tree
```

#### Q: 应用无法启动

**A: 排查步骤：**

```bash
# 1. 检查应用权限
# macOS
xattr -d com.apple.quarantine /path/to/app

# 2. 检查系统兼容性
# 确保目标系统满足最低要求

# 3. 查看应用日志
# macOS: Console.app
# Windows: Event Viewer
# Linux: journalctl

# 4. 调试模式运行
npm run tauri:build:debug
```

---

## 最佳实践总结

### 代码组织

1. **模块化设计**: 按功能划分模块，保持单一职责
2. **类型安全**: 充分利用 TypeScript 的类型系统
3. **错误处理**: 统一的错误处理机制
4. **代码复用**: 提取公共逻辑到 hooks 和工具函数

### 性能优化

1. **懒加载**: 按需加载组件和数据
2. **缓存策略**: 合理使用内存和持久化缓存
3. **批量操作**: 减少频繁的小操作
4. **虚拟化**: 处理大量数据时使用虚拟化技术

### 用户体验

1. **加载状态**: 提供清晰的加载反馈
2. **错误提示**: 友好的错误信息和恢复建议
3. **响应式设计**: 适配不同屏幕尺寸
4. **无障碍访问**: 支持键盘导航和屏幕阅读器

### 开发效率

1. **自动化测试**: 保证代码质量
2. **代码规范**: 统一的代码风格
3. **文档维护**: 及时更新文档
4. **持续集成**: 自动化构建和部署

---

这份开发指南涵盖了 Claudia 项目开发的各个方面，从环境搭建到性能优化，从代码规范到问题排查。遵循这些指南可以帮助开发者更高效地参与项目开发，并保证代码质量和用户体验。